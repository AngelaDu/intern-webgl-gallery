_N_E=(window.webpackJsonp_N_E=window.webpackJsonp_N_E||[]).push([[32],{MPD7:function(o,n,i){(window.__NEXT_P=window.__NEXT_P||[]).push(["/gallery/artwork3/helpers/shader.glsl",function(){return i("jre0")}])},jre0:function(o,n,i){"use strict";i.r(n),i.d(n,"vertexShader",(function(){return s})),i.d(n,"fragmentShader",(function(){return t}));var s="\nvarying vec3 vPosition;\nvarying vec3 vNormal;\nvoid main() {\t\n  vec4 pos = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n  vPosition = position;\n  vNormal = normal;\n  gl_Position = pos;\n}",t="\nvarying vec3 vPosition; \nvarying vec3 vNormal;\nuniform float u_time;\nuniform vec3 vBallPos0;\nuniform vec3 vBallPos1;\nuniform vec3 vBallPos2;\nuniform vec3 vBallPos3;\nuniform vec3 vBallPos4;\nuniform vec3 vBallPos5;\nuniform vec3 vCenter;\nuniform float radius;\n\n#define PI 3.14159265359\n\nfloat random (vec2 st) {\n  return fract(sin(dot(st.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nvoid main (void)\n{\n  // constants\n  vec3 color1 = vec3(0.6, 0.5, 0.8);\n  vec3 color2 = vec3(0.9, 0.4, 0.7);\n  vec3 color3 = vec3(0.2, 0.5, 0.3);\n  vec3 color4 = vec3(0.7, 0.2, 0.5);\n  vec3 color5 = vec3(0.3, 0.2, 0.1);\n  float adJust = radius + 100.0; // changes the radius size\n  float stepMin = 0.3;\n  float stepMax = 1.0;\n\n  // get distances\n  float d1 = clamp(abs(distance(vBallPos0.xz, vPosition.xz)) / adJust, 0.0, 1.0);\n  float d2 = clamp(abs(distance(vBallPos1.xz, vPosition.xz)) / adJust, 0.0, 1.0);\n  float d3 = clamp(abs(distance(vBallPos2.xz, vPosition.xz)) / adJust, 0.0, 1.0);\n  float d4 = clamp(abs(distance(vBallPos3.xz, vPosition.xz)) / adJust, 0.0, 1.0);\n  float d5 = clamp(abs(distance(vBallPos4.xz, vPosition.xz)) / adJust, 0.0, 1.0);\n  float d6 = clamp(abs(distance(vBallPos5.xz, vPosition.xz)) / adJust, 0.0, 1.0);\n\n  // smoothstep\n  /*\n  d1 = smoothstep(stepMin, stepMax, d1);\n  d2 = smoothstep(stepMin, stepMax, d2);\n  d3 = smoothstep(stepMin, stepMax, d3);\n  d4 = smoothstep(stepMin, stepMax, d4);\n  d5 = smoothstep(stepMin, stepMax, d5);\n  d6 = smoothstep(stepMin, stepMax, d6); */\n\n  // assemble colors\n  float d = d1 * d2 * d3 * d4 * d5 * d6;\n\n  // mixes explorations\n  vec3 mix1 = mix(color1, color2, d1);\n  vec3 mix2 = mix(mix1, color3, d2);\n  vec3 mix3 = mix(mix2, color4, d3);\n  vec3 mix4 = mix(mix3, color5, d4);\n  vec3 color = mix1 * mix2 * mix3 * mix4; \n\n  // final output\n  color = mix(color2, color1, d + random(vPosition.xz) * 5. * sin(u_time + cos(d + vNormal.y)) / (0.5 + fract(abs(cos(u_time + vPosition.x)))));\n  gl_FragColor = vec4(color.r, clamp(color.g + 0.7*(radius / 1000.0), 0.0, 0.75), vNormal.x- sin(u_time / vPosition.x + vPosition.z), 1.0);\n\n  // gl_FragColor = vec4(vec3(d2), 1.0);\n}\n"}},[["MPD7",0]]]);